{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/joaocardoso193/Desktop/Actual Food/parent-child-apps-communication-proof-of-concept/svelte-parent-app/packages/rdb:svelte-meteor-data/autorun.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser.legacy"},"sourceFileName":"packages/rdb:svelte-meteor-data/autorun.js","filename":"/Users/joaocardoso193/Desktop/Actual Food/parent-child-apps-communication-proof-of-concept/svelte-parent-app/packages/rdb:svelte-meteor-data/autorun.js","targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/joaocardoso193/Desktop/Actual Food/parent-child-apps-communication-proof-of-concept/svelte-parent-app","root":"/Users/joaocardoso193/Desktop/Actual Food/parent-child-apps-communication-proof-of-concept/svelte-parent-app","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":true,"enforceStrictMode":false,"dynamicImport":true}},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":{},"_verified":{},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.15.3","helpers":true,"useESModules":false,"corejs":false}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true}},{"key":"base$0$3","visitor":{"FunctionExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$4","visitor":{"ForInStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-chaining","visitor":{"_exploded":true,"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_verified":true},"options":{}},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{}},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"proposal-logical-assignment-operators","visitor":{"_exploded":{},"_verified":{},"AssignmentExpression":{"enter":[null]}},"options":{}},{"key":"transform-arrow-functions","visitor":{"ArrowFunctionExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-block-scoped-functions","visitor":{"BlockStatement":{"enter":[null]},"SwitchCase":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-block-scoping","visitor":{"VariableDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"_exploded":true,"BlockStatement":{"enter":[null]},"SwitchStatement":{"enter":[null]},"Program":{"enter":[null]},"_verified":true,"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-classes","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"transform-computed-properties","visitor":{"ObjectExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"transform-destructuring","visitor":{"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"VariableDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-for-of","visitor":{"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-object-super","visitor":{"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"transform-shorthand-properties","visitor":{"ObjectMethod":{"enter":[null]},"ObjectProperty":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-spread","visitor":{"ArrayExpression":{"enter":[null]},"CallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-sticky-regex","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"transform-typeof-symbol","visitor":{"UnaryExpression":{"enter":[null]},"_exploded":true,"_verified":true,"BlockStatement":{"enter":[null]},"CatchClause":{"enter":[null]},"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"Program":{"enter":[null]},"ObjectMethod":{"enter":[null]},"SwitchStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ForOfStatement":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"StaticBlock":{"enter":[null]},"TSModuleBlock":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectPattern":{"enter":[null]}},"options":{}},{"key":"transform-unicode-regex","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-property-literals","visitor":{"ObjectProperty":{"exit":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"regenerator-transform","visitor":{"_exploded":true,"_verified":true,"ObjectMethod":{"enter":[null],"exit":[null]},"ClassMethod":{"enter":[null],"exit":[null]},"ClassPrivateMethod":{"enter":[null],"exit":[null]},"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]}},"options":{}}],"presets":[],"generatorOpts":{"filename":"/Users/joaocardoso193/Desktop/Actual Food/parent-child-apps-communication-proof-of-concept/svelte-parent-app/packages/rdb:svelte-meteor-data/autorun.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/rdb:svelte-meteor-data/autorun.js"}},"code":"var _createForOfIteratorHelperLoose;\n\nmodule.link(\"@babel/runtime/helpers/createForOfIteratorHelperLoose\", {\n  default: function (v) {\n    _createForOfIteratorHelperLoose = v;\n  }\n}, 0);\n\nvar _toConsumableArray;\n\nmodule.link(\"@babel/runtime/helpers/toConsumableArray\", {\n  default: function (v) {\n    _toConsumableArray = v;\n  }\n}, 1);\nvar Tracker;\nmodule.link(\"meteor/tracker\", {\n  Tracker: function (v) {\n    Tracker = v;\n  }\n}, 0);\nvar current_component, schedule_update, dirty_components;\nmodule.link(\"svelte/internal\", {\n  current_component: function (v) {\n    current_component = v;\n  },\n  schedule_update: function (v) {\n    schedule_update = v;\n  },\n  dirty_components: function (v) {\n    dirty_components = v;\n  }\n}, 1);\nvar _autorun = Tracker.autorun;\nvar _nonreactive = Tracker.nonreactive;\n\nfunction svelteAwareAutorun(f, options) {\n  var component = current_component;\n\n  var computation = _autorun.apply(this, arguments);\n\n  if (component) {\n    // We're inside a Svelte component.  We have to stop the computation when\n    // the component is destroyed.\n    _autoStopComputation(computation, component);\n  }\n\n  return computation;\n}\n\nTracker.autorun = svelteAwareAutorun;\n\nTracker.nonreactive = function () {\n  function nonreactive(f) {\n    if (current_component) {\n      // A Tracker.autorun inside a Tracker.nonreactive should behave normally,\n      // without the special Svelte stuff.\n      var prevAutorun = Tracker.autorun;\n      Tracker.autorun = _autorun;\n\n      try {\n        return _nonreactive.apply(this, arguments);\n      } finally {\n        Tracker.autorun = prevAutorun;\n      }\n    } else {\n      return _nonreactive.apply(this, arguments);\n    }\n  }\n\n  return nonreactive;\n}();\n\nfunction _autoStopComputation(computation, component) {\n  var $$ = component.$$;\n  $$.on_destroy.push(computation.stop.bind(computation));\n\n  if (!$$.ctx) {\n    // We're in initialization, so nothing else to do.\n    return;\n  }\n\n  if ($$.fragment && $$.dirty[0] === -1) {\n    // We have a fragment, but it's set to the initial dirty state, so we must\n    // be in on onMount or so.  Don't do anything special, then.\n    return;\n  } // We are in a reactive Svelte update.  That means that we'll need to stop the\n  // computation the next time that it is run.  But we don't know when that is,\n  // because the next update may or may not hit this autorun again, depending on\n  // the dirty flags.\n  // So, we simply stop all computations the next time that the update is run,\n  // but we keep listening for invalidations, so that if one of them becomes\n  // invalid, we can force Svelte to re-run the updates to make it hit the\n  // autorun again.\n  // But first, remember which dirty flags made this autorun trigger, so that we\n  // can reuse these bits to force Svelte to re-hit the autorun.\n  // This will unfortunately most of the time be all bits set, since the first\n  // time it is called is usually during initialization.  But if the autorun is\n  // first enabled by a Svelte variable change, it will be a bit more efficient.\n\n\n  computation._savedDirty = _toConsumableArray($$.dirty);\n\n  if ($$._stopComputations) {\n    $$._stopComputations.push(computation);\n\n    return;\n  }\n\n  $$._stopComputations = [computation]; // Temporary hook around the update function so that it stops our computation\n  // the next time it is called.\n\n  var _update = $$.update;\n\n  $$.update = function () {\n    // Optimization: are we about to rerun everything?  If so, don't bother with\n    // onInvalidate, just stop the computations right here.\n    if ($$.dirty.every(function (d) {\n      return d === 0x7fffffff;\n    })) {\n      $$._stopComputations.forEach(function (comp) {\n        return comp.stop();\n      });\n    } else {\n      var _loop = function (comp) {\n        comp.stopped = true;\n        comp.onInvalidate(function () {\n          if ($$.dirty[0] === -1) {\n            // We're the first to mark it dirty since the last update.\n            dirty_components.push(component);\n            schedule_update();\n            $$.dirty.fill(0);\n          }\n\n          comp._savedDirty.forEach(function (mask, i) {\n            $$.dirty[i] |= mask & 0x7fffffff;\n          });\n        });\n      };\n\n      // Otherwise, we are not sure whether all the autorun blocks will run\n      // again, so we prevent the computations from continuing to run, but will\n      // continue to watch it for changes.  If there is a change, we require the\n      // update to be run again.\n      for (var _iterator = _createForOfIteratorHelperLoose($$._stopComputations), _step; !(_step = _iterator()).done;) {\n        var comp = _step.value;\n\n        _loop(comp);\n      }\n    } // Leave everything as it was, so that the overhead is removed if the\n    // Tracker.autorun was under a condition that has now becomes false.\n\n\n    delete $$._stopComputations;\n    $$.update = _update;\n    return _update();\n  };\n}","map":{"version":3,"sources":["packages/rdb:svelte-meteor-data/autorun.js"],"names":["_createForOfIteratorHelperLoose","module","link","default","v","_toConsumableArray","Tracker","current_component","schedule_update","dirty_components","_autorun","autorun","_nonreactive","nonreactive","svelteAwareAutorun","f","options","component","computation","apply","arguments","_autoStopComputation","prevAutorun","$$","on_destroy","push","stop","bind","ctx","fragment","dirty","_savedDirty","_stopComputations","_update","update","every","d","forEach","comp","stopped","onInvalidate","fill","mask","i"],"mappings":"AAAA,IAAIA,+BAAJ;;AAAoCC,MAAM,CAACC,IAAP,CAAY,uDAAZ,EAAoE;AAACC,EAAAA,OAAO,EAAC,UAASC,CAAT,EAAW;AAACJ,IAAAA,+BAA+B,GAACI,CAAhC;AAAkC;AAAvD,CAApE,EAA6H,CAA7H;;AAAgI,IAAIC,kBAAJ;;AAAuBJ,MAAM,CAACC,IAAP,CAAY,0CAAZ,EAAuD;AAACC,EAAAA,OAAO,EAAC,UAASC,CAAT,EAAW;AAACC,IAAAA,kBAAkB,GAACD,CAAnB;AAAqB;AAA1C,CAAvD,EAAmG,CAAnG;AAA3L,IAAIE,OAAJ;AAAYL,MAAM,CAACC,IAAP,CAAY,gBAAZ,EAA6B;AAACI,EAAAA,OAAO,EAAC,UAASF,CAAT,EAAW;AAACE,IAAAA,OAAO,GAACF,CAAR;AAAU;AAA/B,CAA7B,EAA8D,CAA9D;AAAiE,IAAIG,iBAAJ,EAAsBC,eAAtB,EAAsCC,gBAAtC;AAAuDR,MAAM,CAACC,IAAP,CAAY,iBAAZ,EAA8B;AAACK,EAAAA,iBAAiB,EAAC,UAASH,CAAT,EAAW;AAACG,IAAAA,iBAAiB,GAACH,CAAlB;AAAoB,GAAnD;AAAoDI,EAAAA,eAAe,EAAC,UAASJ,CAAT,EAAW;AAACI,IAAAA,eAAe,GAACJ,CAAhB;AAAkB,GAAlG;AAAmGK,EAAAA,gBAAgB,EAAC,UAASL,CAAT,EAAW;AAACK,IAAAA,gBAAgB,GAACL,CAAjB;AAAmB;AAAnJ,CAA9B,EAAmL,CAAnL;AAUpI,IAAMM,QAAQ,GAAGJ,OAAO,CAACK,OAAzB;AACA,IAAMC,YAAY,GAAGN,OAAO,CAACO,WAA7B;;AAEA,SAASC,kBAAT,CAA4BC,CAA5B,EAA+BC,OAA/B,EAAwC;AACtC,MAAMC,SAAS,GAAGV,iBAAlB;;AACA,MAAMW,WAAW,GAAGR,QAAQ,CAACS,KAAT,CAAe,IAAf,EAAqBC,SAArB,CAApB;;AACA,MAAIH,SAAJ,EAAe;AACb;AACA;AACAI,IAAAA,oBAAoB,CAACH,WAAD,EAAcD,SAAd,CAApB;AACD;;AACD,SAAOC,WAAP;AACD;;AAEDZ,OAAO,CAACK,OAAR,GAAkBG,kBAAlB;;AAEAR,OAAO,CAACO,WAAR;AAAsB,WAASA,WAAT,CAAqBE,CAArB,EAAwB;AAC5C,QAAIR,iBAAJ,EAAuB;AACrB;AACA;AACA,UAAMe,WAAW,GAAGhB,OAAO,CAACK,OAA5B;AACAL,MAAAA,OAAO,CAACK,OAAR,GAAkBD,QAAlB;;AACA,UAAI;AACF,eAAOE,YAAY,CAACO,KAAb,CAAmB,IAAnB,EAAyBC,SAAzB,CAAP;AACD,OAFD,SAEU;AACRd,QAAAA,OAAO,CAACK,OAAR,GAAkBW,WAAlB;AACD;AACF,KAVD,MAUO;AACL,aAAOV,YAAY,CAACO,KAAb,CAAmB,IAAnB,EAAyBC,SAAzB,CAAP;AACD;AACF;;AAdD,SAA+BP,WAA/B;AAAA;;AAgBA,SAASQ,oBAAT,CAA8BH,WAA9B,EAA2CD,SAA3C,EAAsD;AACpD,MAAMM,EAAE,GAAGN,SAAS,CAACM,EAArB;AACAA,EAAAA,EAAE,CAACC,UAAH,CAAcC,IAAd,CAAmBP,WAAW,CAACQ,IAAZ,CAAiBC,IAAjB,CAAsBT,WAAtB,CAAnB;;AACA,MAAI,CAACK,EAAE,CAACK,GAAR,EAAa;AACX;AACA;AACD;;AAED,MAAIL,EAAE,CAACM,QAAH,IAAeN,EAAE,CAACO,KAAH,CAAS,CAAT,MAAgB,CAAC,CAApC,EAAuC;AACrC;AACA;AACA;AACD,GAZmD,CAcpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;AACAZ,EAAAA,WAAW,CAACa,WAAZ,sBAA8BR,EAAE,CAACO,KAAjC;;AAEA,MAAIP,EAAE,CAACS,iBAAP,EAA0B;AACxBT,IAAAA,EAAE,CAACS,iBAAH,CAAqBP,IAArB,CAA0BP,WAA1B;;AACA;AACD;;AAEDK,EAAAA,EAAE,CAACS,iBAAH,GAAuB,CAACd,WAAD,CAAvB,CAnCoD,CAqCpD;AACA;;AACA,MAAMe,OAAO,GAAGV,EAAE,CAACW,MAAnB;;AACAX,EAAAA,EAAE,CAACW,MAAH,GAAY,YAAM;AAChB;AACA;AACA,QAAIX,EAAE,CAACO,KAAH,CAASK,KAAT,CAAe,UAAAC,CAAC;AAAA,aAAKA,CAAC,KAAK,UAAX;AAAA,KAAhB,CAAJ,EAA6C;AAC3Cb,MAAAA,EAAE,CAACS,iBAAH,CAAqBK,OAArB,CAA6B,UAAAC,IAAI;AAAA,eAAIA,IAAI,CAACZ,IAAL,EAAJ;AAAA,OAAjC;AACD,KAFD,MAEO;AAAA,4BAKMY,IALN;AAMHA,QAAAA,IAAI,CAACC,OAAL,GAAe,IAAf;AACAD,QAAAA,IAAI,CAACE,YAAL,CAAkB,YAAM;AACtB,cAAIjB,EAAE,CAACO,KAAH,CAAS,CAAT,MAAgB,CAAC,CAArB,EAAwB;AACtB;AACArB,YAAAA,gBAAgB,CAACgB,IAAjB,CAAsBR,SAAtB;AACAT,YAAAA,eAAe;AACfe,YAAAA,EAAE,CAACO,KAAH,CAASW,IAAT,CAAc,CAAd;AACD;;AACDH,UAAAA,IAAI,CAACP,WAAL,CAAiBM,OAAjB,CAAyB,UAACK,IAAD,EAAOC,CAAP,EAAa;AACpCpB,YAAAA,EAAE,CAACO,KAAH,CAASa,CAAT,KAAeD,IAAI,GAAG,UAAtB;AACD,WAFD;AAGD,SAVD;AAPG;;AACL;AACA;AACA;AACA;AACA,2DAAmBnB,EAAE,CAACS,iBAAtB,wCAAyC;AAAA,YAA9BM,IAA8B;;AAAA,cAA9BA,IAA8B;AAaxC;AACF,KAxBe,CA0BhB;AACA;;;AACA,WAAOf,EAAE,CAACS,iBAAV;AACAT,IAAAA,EAAE,CAACW,MAAH,GAAYD,OAAZ;AACA,WAAOA,OAAO,EAAd;AACD,GA/BD;AAgCD","sourcesContent":["/**\n * Makes Tracker.autorun() computations automatically stop when the component is\n * destroyed, or, if run from a reactive Svelte computation, when the update\n * function is run again.\n */\n\nimport { Tracker } from 'meteor/tracker';\nimport { current_component, schedule_update, dirty_components } from 'svelte/internal';\n\n\nconst _autorun = Tracker.autorun;\nconst _nonreactive = Tracker.nonreactive;\n\nfunction svelteAwareAutorun(f, options) {\n  const component = current_component;\n  const computation = _autorun.apply(this, arguments);\n  if (component) {\n    // We're inside a Svelte component.  We have to stop the computation when\n    // the component is destroyed.\n    _autoStopComputation(computation, component);\n  }\n  return computation;\n}\n\nTracker.autorun = svelteAwareAutorun;\n\nTracker.nonreactive = function nonreactive(f) {\n  if (current_component) {\n    // A Tracker.autorun inside a Tracker.nonreactive should behave normally,\n    // without the special Svelte stuff.\n    const prevAutorun = Tracker.autorun;\n    Tracker.autorun = _autorun;\n    try {\n      return _nonreactive.apply(this, arguments);\n    } finally {\n      Tracker.autorun = prevAutorun;\n    }\n  } else {\n    return _nonreactive.apply(this, arguments);\n  }\n};\n\nfunction _autoStopComputation(computation, component) {\n  const $$ = component.$$;\n  $$.on_destroy.push(computation.stop.bind(computation));\n  if (!$$.ctx) {\n    // We're in initialization, so nothing else to do.\n    return;\n  }\n\n  if ($$.fragment && $$.dirty[0] === -1) {\n    // We have a fragment, but it's set to the initial dirty state, so we must\n    // be in on onMount or so.  Don't do anything special, then.\n    return;\n  }\n\n  // We are in a reactive Svelte update.  That means that we'll need to stop the\n  // computation the next time that it is run.  But we don't know when that is,\n  // because the next update may or may not hit this autorun again, depending on\n  // the dirty flags.\n  // So, we simply stop all computations the next time that the update is run,\n  // but we keep listening for invalidations, so that if one of them becomes\n  // invalid, we can force Svelte to re-run the updates to make it hit the\n  // autorun again.\n\n  // But first, remember which dirty flags made this autorun trigger, so that we\n  // can reuse these bits to force Svelte to re-hit the autorun.\n  // This will unfortunately most of the time be all bits set, since the first\n  // time it is called is usually during initialization.  But if the autorun is\n  // first enabled by a Svelte variable change, it will be a bit more efficient.\n  computation._savedDirty = [...$$.dirty];\n\n  if ($$._stopComputations) {\n    $$._stopComputations.push(computation);\n    return;\n  }\n\n  $$._stopComputations = [computation];\n\n  // Temporary hook around the update function so that it stops our computation\n  // the next time it is called.\n  const _update = $$.update;\n  $$.update = () => {\n    // Optimization: are we about to rerun everything?  If so, don't bother with\n    // onInvalidate, just stop the computations right here.\n    if ($$.dirty.every(d => (d === 0x7fffffff))) {\n      $$._stopComputations.forEach(comp => comp.stop());\n    } else {\n      // Otherwise, we are not sure whether all the autorun blocks will run\n      // again, so we prevent the computations from continuing to run, but will\n      // continue to watch it for changes.  If there is a change, we require the\n      // update to be run again.\n      for (const comp of $$._stopComputations) {\n        comp.stopped = true;\n        comp.onInvalidate(() => {\n          if ($$.dirty[0] === -1) {\n            // We're the first to mark it dirty since the last update.\n            dirty_components.push(component);\n            schedule_update();\n            $$.dirty.fill(0);\n          }\n          comp._savedDirty.forEach((mask, i) => {\n            $$.dirty[i] |= mask & 0x7fffffff;\n          });\n        });\n      }\n    }\n\n    // Leave everything as it was, so that the overhead is removed if the\n    // Tracker.autorun was under a condition that has now becomes false.\n    delete $$._stopComputations;\n    $$.update = _update;\n    return _update();\n  };\n}\n"]},"sourceType":"module","hash":"8585192801e4cc0b1669950288fc916ea7333cb4"}
