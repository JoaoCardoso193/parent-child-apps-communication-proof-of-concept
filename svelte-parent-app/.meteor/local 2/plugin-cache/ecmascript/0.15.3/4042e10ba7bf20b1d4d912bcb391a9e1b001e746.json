{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/joaocardoso193/Desktop/Actual Food/parent-child-apps-communication-proof-of-concept/svelte-parent-app/packages/rdb:svelte-meteor-data/autorun.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser"},"sourceFileName":"packages/rdb:svelte-meteor-data/autorun.js","filename":"/Users/joaocardoso193/Desktop/Actual Food/parent-child-apps-communication-proof-of-concept/svelte-parent-app/packages/rdb:svelte-meteor-data/autorun.js","targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/joaocardoso193/Desktop/Actual Food/parent-child-apps-communication-proof-of-concept/svelte-parent-app","root":"/Users/joaocardoso193/Desktop/Actual Food/parent-child-apps-communication-proof-of-concept/svelte-parent-app","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true}},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":{},"_verified":{},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.15.3","helpers":true,"useESModules":false,"corejs":false}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-chaining","visitor":{"_exploded":true,"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_verified":true},"options":{}},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{}},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"proposal-logical-assignment-operators","visitor":{"_exploded":{},"_verified":{},"AssignmentExpression":{"enter":[null]}},"options":{}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}}],"presets":[],"generatorOpts":{"filename":"/Users/joaocardoso193/Desktop/Actual Food/parent-child-apps-communication-proof-of-concept/svelte-parent-app/packages/rdb:svelte-meteor-data/autorun.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/rdb:svelte-meteor-data/autorun.js"}},"code":"let Tracker;\nmodule.link(\"meteor/tracker\", {\n  Tracker(v) {\n    Tracker = v;\n  }\n\n}, 0);\nlet current_component, schedule_update, dirty_components;\nmodule.link(\"svelte/internal\", {\n  current_component(v) {\n    current_component = v;\n  },\n\n  schedule_update(v) {\n    schedule_update = v;\n  },\n\n  dirty_components(v) {\n    dirty_components = v;\n  }\n\n}, 1);\nconst _autorun = Tracker.autorun;\nconst _nonreactive = Tracker.nonreactive;\n\nfunction svelteAwareAutorun(f, options) {\n  const component = current_component;\n\n  const computation = _autorun.apply(this, arguments);\n\n  if (component) {\n    // We're inside a Svelte component.  We have to stop the computation when\n    // the component is destroyed.\n    _autoStopComputation(computation, component);\n  }\n\n  return computation;\n}\n\nTracker.autorun = svelteAwareAutorun;\n\nTracker.nonreactive = function nonreactive(f) {\n  if (current_component) {\n    // A Tracker.autorun inside a Tracker.nonreactive should behave normally,\n    // without the special Svelte stuff.\n    const prevAutorun = Tracker.autorun;\n    Tracker.autorun = _autorun;\n\n    try {\n      return _nonreactive.apply(this, arguments);\n    } finally {\n      Tracker.autorun = prevAutorun;\n    }\n  } else {\n    return _nonreactive.apply(this, arguments);\n  }\n};\n\nfunction _autoStopComputation(computation, component) {\n  const $$ = component.$$;\n  $$.on_destroy.push(computation.stop.bind(computation));\n\n  if (!$$.ctx) {\n    // We're in initialization, so nothing else to do.\n    return;\n  }\n\n  if ($$.fragment && $$.dirty[0] === -1) {\n    // We have a fragment, but it's set to the initial dirty state, so we must\n    // be in on onMount or so.  Don't do anything special, then.\n    return;\n  } // We are in a reactive Svelte update.  That means that we'll need to stop the\n  // computation the next time that it is run.  But we don't know when that is,\n  // because the next update may or may not hit this autorun again, depending on\n  // the dirty flags.\n  // So, we simply stop all computations the next time that the update is run,\n  // but we keep listening for invalidations, so that if one of them becomes\n  // invalid, we can force Svelte to re-run the updates to make it hit the\n  // autorun again.\n  // But first, remember which dirty flags made this autorun trigger, so that we\n  // can reuse these bits to force Svelte to re-hit the autorun.\n  // This will unfortunately most of the time be all bits set, since the first\n  // time it is called is usually during initialization.  But if the autorun is\n  // first enabled by a Svelte variable change, it will be a bit more efficient.\n\n\n  computation._savedDirty = [...$$.dirty];\n\n  if ($$._stopComputations) {\n    $$._stopComputations.push(computation);\n\n    return;\n  }\n\n  $$._stopComputations = [computation]; // Temporary hook around the update function so that it stops our computation\n  // the next time it is called.\n\n  const _update = $$.update;\n\n  $$.update = () => {\n    // Optimization: are we about to rerun everything?  If so, don't bother with\n    // onInvalidate, just stop the computations right here.\n    if ($$.dirty.every(d => d === 0x7fffffff)) {\n      $$._stopComputations.forEach(comp => comp.stop());\n    } else {\n      // Otherwise, we are not sure whether all the autorun blocks will run\n      // again, so we prevent the computations from continuing to run, but will\n      // continue to watch it for changes.  If there is a change, we require the\n      // update to be run again.\n      for (const comp of $$._stopComputations) {\n        comp.stopped = true;\n        comp.onInvalidate(() => {\n          if ($$.dirty[0] === -1) {\n            // We're the first to mark it dirty since the last update.\n            dirty_components.push(component);\n            schedule_update();\n            $$.dirty.fill(0);\n          }\n\n          comp._savedDirty.forEach((mask, i) => {\n            $$.dirty[i] |= mask & 0x7fffffff;\n          });\n        });\n      }\n    } // Leave everything as it was, so that the overhead is removed if the\n    // Tracker.autorun was under a condition that has now becomes false.\n\n\n    delete $$._stopComputations;\n    $$.update = _update;\n    return _update();\n  };\n}","map":{"version":3,"sources":["packages/rdb:svelte-meteor-data/autorun.js"],"names":["Tracker","module","link","v","current_component","schedule_update","dirty_components","_autorun","autorun","_nonreactive","nonreactive","svelteAwareAutorun","f","options","component","computation","apply","arguments","_autoStopComputation","prevAutorun","$$","on_destroy","push","stop","bind","ctx","fragment","dirty","_savedDirty","_stopComputations","_update","update","every","d","forEach","comp","stopped","onInvalidate","fill","mask","i"],"mappings":"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","sourcesContent":["/**\n * Makes Tracker.autorun() computations automatically stop when the component is\n * destroyed, or, if run from a reactive Svelte computation, when the update\n * function is run again.\n */\n\nimport { Tracker } from 'meteor/tracker';\nimport { current_component, schedule_update, dirty_components } from 'svelte/internal';\n\n\nconst _autorun = Tracker.autorun;\nconst _nonreactive = Tracker.nonreactive;\n\nfunction svelteAwareAutorun(f, options) {\n  const component = current_component;\n  const computation = _autorun.apply(this, arguments);\n  if (component) {\n    // We're inside a Svelte component.  We have to stop the computation when\n    // the component is destroyed.\n    _autoStopComputation(computation, component);\n  }\n  return computation;\n}\n\nTracker.autorun = svelteAwareAutorun;\n\nTracker.nonreactive = function nonreactive(f) {\n  if (current_component) {\n    // A Tracker.autorun inside a Tracker.nonreactive should behave normally,\n    // without the special Svelte stuff.\n    const prevAutorun = Tracker.autorun;\n    Tracker.autorun = _autorun;\n    try {\n      return _nonreactive.apply(this, arguments);\n    } finally {\n      Tracker.autorun = prevAutorun;\n    }\n  } else {\n    return _nonreactive.apply(this, arguments);\n  }\n};\n\nfunction _autoStopComputation(computation, component) {\n  const $$ = component.$$;\n  $$.on_destroy.push(computation.stop.bind(computation));\n  if (!$$.ctx) {\n    // We're in initialization, so nothing else to do.\n    return;\n  }\n\n  if ($$.fragment && $$.dirty[0] === -1) {\n    // We have a fragment, but it's set to the initial dirty state, so we must\n    // be in on onMount or so.  Don't do anything special, then.\n    return;\n  }\n\n  // We are in a reactive Svelte update.  That means that we'll need to stop the\n  // computation the next time that it is run.  But we don't know when that is,\n  // because the next update may or may not hit this autorun again, depending on\n  // the dirty flags.\n  // So, we simply stop all computations the next time that the update is run,\n  // but we keep listening for invalidations, so that if one of them becomes\n  // invalid, we can force Svelte to re-run the updates to make it hit the\n  // autorun again.\n\n  // But first, remember which dirty flags made this autorun trigger, so that we\n  // can reuse these bits to force Svelte to re-hit the autorun.\n  // This will unfortunately most of the time be all bits set, since the first\n  // time it is called is usually during initialization.  But if the autorun is\n  // first enabled by a Svelte variable change, it will be a bit more efficient.\n  computation._savedDirty = [...$$.dirty];\n\n  if ($$._stopComputations) {\n    $$._stopComputations.push(computation);\n    return;\n  }\n\n  $$._stopComputations = [computation];\n\n  // Temporary hook around the update function so that it stops our computation\n  // the next time it is called.\n  const _update = $$.update;\n  $$.update = () => {\n    // Optimization: are we about to rerun everything?  If so, don't bother with\n    // onInvalidate, just stop the computations right here.\n    if ($$.dirty.every(d => (d === 0x7fffffff))) {\n      $$._stopComputations.forEach(comp => comp.stop());\n    } else {\n      // Otherwise, we are not sure whether all the autorun blocks will run\n      // again, so we prevent the computations from continuing to run, but will\n      // continue to watch it for changes.  If there is a change, we require the\n      // update to be run again.\n      for (const comp of $$._stopComputations) {\n        comp.stopped = true;\n        comp.onInvalidate(() => {\n          if ($$.dirty[0] === -1) {\n            // We're the first to mark it dirty since the last update.\n            dirty_components.push(component);\n            schedule_update();\n            $$.dirty.fill(0);\n          }\n          comp._savedDirty.forEach((mask, i) => {\n            $$.dirty[i] |= mask & 0x7fffffff;\n          });\n        });\n      }\n    }\n\n    // Leave everything as it was, so that the overhead is removed if the\n    // Tracker.autorun was under a condition that has now becomes false.\n    delete $$._stopComputations;\n    $$.update = _update;\n    return _update();\n  };\n}\n"]},"sourceType":"module","hash":"4042e10ba7bf20b1d4d912bcb391a9e1b001e746"}
