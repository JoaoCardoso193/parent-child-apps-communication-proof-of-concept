{"sourcePath":"imports/ui/Foods.svelte","path":"imports/ui/Foods.svelte","data":"var _assertThisInitialized;\n\nmodule.link(\"@babel/runtime/helpers/assertThisInitialized\", {\n  default: function (v) {\n    _assertThisInitialized = v;\n  }\n}, 0);\n\nvar _inheritsLoose;\n\nmodule.link(\"@babel/runtime/helpers/inheritsLoose\", {\n  default: function (v) {\n    _inheritsLoose = v;\n  }\n}, 1);\n\nvar _slicedToArray;\n\nmodule.link(\"@babel/runtime/helpers/slicedToArray\", {\n  default: function (v) {\n    _slicedToArray = v;\n  }\n}, 2);\nvar SvelteComponentDev, add_location, append_dev, destroy_each, detach_dev, dispatch_dev, element, init, insert_dev, noop, safe_not_equal, space, validate_each_argument, validate_slots;\nmodule.link(\"svelte/internal\", {\n  SvelteComponentDev: function (v) {\n    SvelteComponentDev = v;\n  },\n  add_location: function (v) {\n    add_location = v;\n  },\n  append_dev: function (v) {\n    append_dev = v;\n  },\n  destroy_each: function (v) {\n    destroy_each = v;\n  },\n  detach_dev: function (v) {\n    detach_dev = v;\n  },\n  dispatch_dev: function (v) {\n    dispatch_dev = v;\n  },\n  element: function (v) {\n    element = v;\n  },\n  init: function (v) {\n    init = v;\n  },\n  insert_dev: function (v) {\n    insert_dev = v;\n  },\n  noop: function (v) {\n    noop = v;\n  },\n  safe_not_equal: function (v) {\n    safe_not_equal = v;\n  },\n  space: function (v) {\n    space = v;\n  },\n  validate_each_argument: function (v) {\n    validate_each_argument = v;\n  },\n  validate_slots: function (v) {\n    validate_slots = v;\n  }\n}, 0);\n\nvar _m_createReactiveWrapper;\n\nmodule.link(\"meteor/zodern:melte/tracker\", {\n  createReactiveWrapper: function (v) {\n    _m_createReactiveWrapper = v;\n  }\n}, 1);\nvar FoodsCollection;\nmodule.link(\"/imports/db/foodsCollection\", {\n  FoodsCollection: function (v) {\n    FoodsCollection = v;\n  }\n}, 2);\nvar file = \"imports/ui/Foods.svelte\";\n\nfunction get_each_context(ctx, list, i) {\n  var child_ctx = ctx.slice();\n  child_ctx[3] = list[i];\n  return child_ctx;\n} // (27:8) {#each foods as food}\n\n\nfunction create_each_block(ctx) {\n  var p;\n  var block = {\n    c: function () {\n      function create() {\n        p = element(\"p\");\n        p.textContent = \"food.name\";\n        add_location(p, file, 27, 12, 584);\n      }\n\n      return create;\n    }(),\n    m: function () {\n      function mount(target, anchor) {\n        insert_dev(target, p, anchor);\n      }\n\n      return mount;\n    }(),\n    d: function () {\n      function destroy(detaching) {\n        if (detaching) detach_dev(p);\n      }\n\n      return destroy;\n    }()\n  };\n  dispatch_dev(\"SvelteRegisterBlock\", {\n    block: block,\n    id: create_each_block.name,\n    type: \"each\",\n    source: \"(27:8) {#each foods as food}\",\n    ctx: ctx\n  });\n  return block;\n}\n\nfunction create_fragment(ctx) {\n  var div;\n  var h2;\n  var t1;\n  var ul;\n  var each_value =\n  /*foods*/\n  ctx[0];\n  validate_each_argument(each_value);\n  var each_blocks = [];\n\n  for (var i = 0; i < each_value.length; i += 1) {\n    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));\n  }\n\n  var block = {\n    c: function () {\n      function create() {\n        div = element(\"div\");\n        h2 = element(\"h2\");\n        h2.textContent = \"Foods Collection:\";\n        t1 = space();\n        ul = element(\"ul\");\n\n        for (var _i = 0; _i < each_blocks.length; _i += 1) {\n          each_blocks[_i].c();\n        }\n\n        add_location(h2, file, 22, 4, 492);\n        add_location(ul, file, 25, 4, 537);\n        add_location(div, file, 21, 0, 482);\n      }\n\n      return create;\n    }(),\n    l: function () {\n      function claim(nodes) {\n        throw new Error(\"options.hydrate only works if the component was compiled with the `hydratable: true` option\");\n      }\n\n      return claim;\n    }(),\n    m: function () {\n      function mount(target, anchor) {\n        insert_dev(target, div, anchor);\n        append_dev(div, h2);\n        append_dev(div, t1);\n        append_dev(div, ul);\n\n        for (var _i2 = 0; _i2 < each_blocks.length; _i2 += 1) {\n          each_blocks[_i2].m(ul, null);\n        }\n      }\n\n      return mount;\n    }(),\n    p: function () {\n      function update(ctx, _ref) {\n        var _ref2 = _slicedToArray(_ref, 1),\n            dirty = _ref2[0];\n\n        if (dirty &\n        /*foods*/\n        1) {\n          var old_length = each_value.length;\n          each_value =\n          /*foods*/\n          ctx[0];\n          validate_each_argument(each_value);\n\n          var _i3;\n\n          for (_i3 = old_length; _i3 < each_value.length; _i3 += 1) {\n            var child_ctx = get_each_context(ctx, each_value, _i3);\n\n            if (!each_blocks[_i3]) {\n              each_blocks[_i3] = create_each_block(child_ctx);\n\n              each_blocks[_i3].c();\n\n              each_blocks[_i3].m(ul, null);\n            }\n          }\n\n          for (_i3 = each_value.length; _i3 < old_length; _i3 += 1) {\n            each_blocks[_i3].d(1);\n          }\n\n          each_blocks.length = each_value.length;\n        }\n      }\n\n      return update;\n    }(),\n    i: noop,\n    o: noop,\n    d: function () {\n      function destroy(detaching) {\n        if (detaching) detach_dev(div);\n        destroy_each(each_blocks, detaching);\n      }\n\n      return destroy;\n    }()\n  };\n  dispatch_dev(\"SvelteRegisterBlock\", {\n    block: block,\n    id: create_fragment.name,\n    type: \"component\",\n    source: \"\",\n    ctx: ctx\n  });\n  return block;\n}\n\nfunction instance($$self, $$props, $$invalidate) {\n  var _$$props$$$slots = $$props.$$slots,\n      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots,\n      $$scope = $$props.$$scope;\n  validate_slots('Foods', slots, []);\n\n  var _m_tracker0 = _m_createReactiveWrapper();\n\n  var subscriber = Meteor.subscribe('foods');\n  var foods = [];\n  var writable_props = [];\n  Object.keys($$props).forEach(function (key) {\n    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(\"<Foods> was created with unknown prop '\" + key + \"'\");\n  });\n\n  $$self.$capture_state = function () {\n    return {\n      _m_createReactiveWrapper: _m_createReactiveWrapper,\n      _m_tracker0: _m_tracker0,\n      FoodsCollection: FoodsCollection,\n      subscriber: subscriber,\n      foods: foods\n    };\n  };\n\n  $$self.$inject_state = function ($$props) {\n    if ('foods' in $$props) $$invalidate(0, foods = $$props.foods);\n  };\n\n  if ($$props && \"$$inject\" in $$props) {\n    $$self.$inject_state($$props.$$inject);\n  }\n\n  $: _m_tracker0(function () {\n    {\n      if (subscriber.ready()) {\n        $$invalidate(0, foods = FoodsCollection.find({}).fetch());\n      }\n    }\n  });\n\n  return [foods];\n}\n\nvar Foods = /*#__PURE__*/function (_SvelteComponentDev) {\n  _inheritsLoose(Foods, _SvelteComponentDev);\n\n  function Foods(options) {\n    var _this;\n\n    _this = _SvelteComponentDev.call(this, options) || this;\n    init(_assertThisInitialized(_this), options, instance, create_fragment, safe_not_equal, {});\n    dispatch_dev(\"SvelteRegisterComponent\", {\n      component: _assertThisInitialized(_this),\n      tagName: \"Foods\",\n      options: options,\n      id: create_fragment.name\n    });\n    return _this;\n  }\n\n  return Foods;\n}(SvelteComponentDev);\n\nmodule.exportDefault(Foods);","sourceMap":{"version":3,"sources":["Foods.svelte"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;SACsE,iBAAA,KAAA,MAAA,GAAA;;iBAEzD,IAAA,CAAA,CAAA","sourcesContent":["<script>\n    import { createReactiveWrapper as _m_createReactiveWrapper } from \"meteor/zodern:melte/tracker\";\n    const _m_tracker0 = _m_createReactiveWrapper();\n    import { FoodsCollection } from \"/imports/db/foodsCollection\";\n\n    const subscriber = Meteor.subscribe('foods');\n\n    let foods = [];\n\n    $:\n    _m_tracker0(() => {\n        {\n            if(subscriber.ready()){\n                foods = FoodsCollection.find({}).fetch();\n            }\n        }\n    });\n\n\n</script>\n\n<div>\n    <h2>\n        Foods Collection:\n    </h2>\n    <ul>\n        {#each foods as food}\n            <p>food.name</p>\n        {/each}\n    </ul>\n</div>\n"]}}