{"sourcePath":"imports/ui/Message.svelte","path":"imports/ui/Message.svelte","data":"!function (module1) {\n  let SvelteComponentDev, add_location, append_dev, component_subscribe, detach_dev, dispatch_dev, element, empty, globals, init, insert_dev, noop, safe_not_equal, set_data_dev, text, validate_slots, validate_store;\n  module1.link(\"svelte/internal\", {\n    SvelteComponentDev(v) {\n      SvelteComponentDev = v;\n    },\n\n    add_location(v) {\n      add_location = v;\n    },\n\n    append_dev(v) {\n      append_dev = v;\n    },\n\n    component_subscribe(v) {\n      component_subscribe = v;\n    },\n\n    detach_dev(v) {\n      detach_dev = v;\n    },\n\n    dispatch_dev(v) {\n      dispatch_dev = v;\n    },\n\n    element(v) {\n      element = v;\n    },\n\n    empty(v) {\n      empty = v;\n    },\n\n    globals(v) {\n      globals = v;\n    },\n\n    init(v) {\n      init = v;\n    },\n\n    insert_dev(v) {\n      insert_dev = v;\n    },\n\n    noop(v) {\n      noop = v;\n    },\n\n    safe_not_equal(v) {\n      safe_not_equal = v;\n    },\n\n    set_data_dev(v) {\n      set_data_dev = v;\n    },\n\n    text(v) {\n      text = v;\n    },\n\n    validate_slots(v) {\n      validate_slots = v;\n    },\n\n    validate_store(v) {\n      validate_store = v;\n    }\n\n  }, 0);\n  let incomingMessageText;\n  module1.link(\"/imports/api/stores\", {\n    incomingMessageText(v) {\n      incomingMessageText = v;\n    }\n\n  }, 1);\n\n  let ___SVELTE_HMR_HOT_API;\n\n  module1.link(\"meteor/zodern:melte/hmr-runtime.js\", {\n    \"*\"(v) {\n      ___SVELTE_HMR_HOT_API = v;\n    }\n\n  }, 2);\n\n  let ___SVELTE_HMR_HOT_API_PROXY_ADAPTER;\n\n  module1.link(\"meteor/zodern:melte/proxy-adapter.js\", {\n    adapter(v) {\n      ___SVELTE_HMR_HOT_API_PROXY_ADAPTER = v;\n    }\n\n  }, 3);\n  const {\n    console: console_1\n  } = globals;\n  const file = \"imports/ui/Message.svelte\"; // (9:0) {:else}\n\n  function create_else_block(ctx) {\n    let h2;\n    let t0;\n    let t1;\n    const block = {\n      c: function create() {\n        h2 = element(\"h2\");\n        t0 = text(\"Message received: \");\n        t1 = text(\n        /*$incomingMessageText*/\n        ctx[0]);\n        add_location(h2, file, 9, 2, 198);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, h2, anchor);\n        append_dev(h2, t0);\n        append_dev(h2, t1);\n      },\n      p: function update(ctx, dirty) {\n        if (dirty &\n        /*$incomingMessageText*/\n        1) set_data_dev(t1,\n        /*$incomingMessageText*/\n        ctx[0]);\n      },\n      d: function destroy(detaching) {\n        if (detaching) detach_dev(h2);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block,\n      id: create_else_block.name,\n      type: \"else\",\n      source: \"(9:0) {:else}\",\n      ctx\n    });\n    return block;\n  } // (7:0) {#if (!$incomingMessageText)}\n\n\n  function create_if_block(ctx) {\n    let h2;\n    const block = {\n      c: function create() {\n        h2 = element(\"h2\");\n        h2.textContent = \"Listening for messages...\";\n        add_location(h2, file, 7, 2, 153);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, h2, anchor);\n      },\n      p: noop,\n      d: function destroy(detaching) {\n        if (detaching) detach_dev(h2);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block,\n      id: create_if_block.name,\n      type: \"if\",\n      source: \"(7:0) {#if (!$incomingMessageText)}\",\n      ctx\n    });\n    return block;\n  }\n\n  function create_fragment(ctx) {\n    let if_block_anchor;\n\n    function select_block_type(ctx, dirty) {\n      if (!\n      /*$incomingMessageText*/\n      ctx[0]) return create_if_block;\n      return create_else_block;\n    }\n\n    let current_block_type = select_block_type(ctx, -1);\n    let if_block = current_block_type(ctx);\n    const block = {\n      c: function create() {\n        if_block.c();\n        if_block_anchor = empty();\n      },\n      l: function claim(nodes) {\n        throw new Error(\"options.hydrate only works if the component was compiled with the `hydratable: true` option\");\n      },\n      m: function mount(target, anchor) {\n        if_block.m(target, anchor);\n        insert_dev(target, if_block_anchor, anchor);\n      },\n      p: function update(ctx, _ref) {\n        let [dirty] = _ref;\n\n        if (current_block_type === (current_block_type = select_block_type(ctx, dirty)) && if_block) {\n          if_block.p(ctx, dirty);\n        } else {\n          if_block.d(1);\n          if_block = current_block_type(ctx);\n\n          if (if_block) {\n            if_block.c();\n            if_block.m(if_block_anchor.parentNode, if_block_anchor);\n          }\n        }\n      },\n      i: noop,\n      o: noop,\n      d: function destroy(detaching) {\n        if_block.d(detaching);\n        if (detaching) detach_dev(if_block_anchor);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block,\n      id: create_fragment.name,\n      type: \"component\",\n      source: \"\",\n      ctx\n    });\n    return block;\n  }\n\n  function instance($$self, $$props, $$invalidate) {\n    let $incomingMessageText;\n    validate_store(incomingMessageText, 'incomingMessageText');\n    component_subscribe($$self, incomingMessageText, $$value => $$invalidate(0, $incomingMessageText = $$value));\n    let {\n      $$slots: slots = {},\n      $$scope\n    } = $$props;\n    validate_slots('Message', slots, []);\n    console.log($incomingMessageText);\n    const writable_props = [];\n    Object.keys($$props).forEach(key => {\n      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(\"<Message> was created with unknown prop '\".concat(key, \"'\"));\n    });\n\n    $$self.$capture_state = () => ({\n      incomingMessageText,\n      $incomingMessageText\n    });\n\n    return [$incomingMessageText];\n  }\n\n  class Message extends SvelteComponentDev {\n    constructor(options) {\n      super(options);\n      init(this, options, instance, create_fragment, safe_not_equal, {});\n      dispatch_dev(\"SvelteRegisterComponent\", {\n        component: this,\n        tagName: \"Message\",\n        options,\n        id: create_fragment.name\n      });\n    }\n\n  }\n\n  if (module && module.hot) {\n    Message = ___SVELTE_HMR_HOT_API.applyHmr({\n      m: module,\n      id: \"imports/ui/Message.svelte\",\n      hotOptions: {\n        \"preserveLocalState\": false,\n        \"noPreserveStateKey\": [\"@hmr:reset\", \"@!hmr\"],\n        \"preserveAllLocalStateKey\": \"@hmr:keep-all\",\n        \"preserveLocalStateKey\": \"@hmr:keep\",\n        \"noReload\": false,\n        \"optimistic\": true,\n        \"acceptNamedExports\": true,\n        \"acceptAccessors\": true,\n        \"injectCss\": true,\n        \"cssEjectDelay\": 100,\n        \"native\": false,\n        \"importAdapterName\": \"___SVELTE_HMR_HOT_API_PROXY_ADAPTER\",\n        \"noOverlay\": false\n      },\n      Component: Message,\n      ProxyAdapter: ___SVELTE_HMR_HOT_API_PROXY_ADAPTER,\n      acceptable: true,\n      preserveLocalState: false,\n      cssId: undefined,\n      nonCssHash: undefined,\n      ignoreCss: false\n    });\n  }\n\n  module1.exportDefault(Message);\n}.call(this, module);","sourceMap":{"version":3,"sources":[],"names":[],"mappings":""}}