{"sourcePath":"imports/ui/Foods.svelte","path":"imports/ui/Foods.svelte","data":"!function (module1) {\n  let SvelteComponentDev, add_location, append_dev, destroy_each, detach_dev, dispatch_dev, element, init, insert_dev, noop, safe_not_equal, space, validate_each_argument, validate_slots;\n  module1.link(\"svelte/internal\", {\n    SvelteComponentDev(v) {\n      SvelteComponentDev = v;\n    },\n\n    add_location(v) {\n      add_location = v;\n    },\n\n    append_dev(v) {\n      append_dev = v;\n    },\n\n    destroy_each(v) {\n      destroy_each = v;\n    },\n\n    detach_dev(v) {\n      detach_dev = v;\n    },\n\n    dispatch_dev(v) {\n      dispatch_dev = v;\n    },\n\n    element(v) {\n      element = v;\n    },\n\n    init(v) {\n      init = v;\n    },\n\n    insert_dev(v) {\n      insert_dev = v;\n    },\n\n    noop(v) {\n      noop = v;\n    },\n\n    safe_not_equal(v) {\n      safe_not_equal = v;\n    },\n\n    space(v) {\n      space = v;\n    },\n\n    validate_each_argument(v) {\n      validate_each_argument = v;\n    },\n\n    validate_slots(v) {\n      validate_slots = v;\n    }\n\n  }, 0);\n\n  let _m_createReactiveWrapper;\n\n  module1.link(\"meteor/zodern:melte/tracker\", {\n    createReactiveWrapper(v) {\n      _m_createReactiveWrapper = v;\n    }\n\n  }, 1);\n  let FoodsCollection;\n  module1.link(\"/imports/db/foodsCollection\", {\n    FoodsCollection(v) {\n      FoodsCollection = v;\n    }\n\n  }, 2);\n\n  let ___SVELTE_HMR_HOT_API;\n\n  module1.link(\"meteor/zodern:melte/hmr-runtime.js\", {\n    \"*\"(v) {\n      ___SVELTE_HMR_HOT_API = v;\n    }\n\n  }, 3);\n\n  let ___SVELTE_HMR_HOT_API_PROXY_ADAPTER;\n\n  module1.link(\"meteor/zodern:melte/proxy-adapter.js\", {\n    adapter(v) {\n      ___SVELTE_HMR_HOT_API_PROXY_ADAPTER = v;\n    }\n\n  }, 4);\n  const file = \"imports/ui/Foods.svelte\";\n\n  function get_each_context(ctx, list, i) {\n    const child_ctx = ctx.slice();\n    child_ctx[3] = list[i];\n    return child_ctx;\n  } // (27:8) {#each foods as food}\n\n\n  function create_each_block(ctx) {\n    let p;\n    const block = {\n      c: function create() {\n        p = element(\"p\");\n        p.textContent = \"food.name\";\n        add_location(p, file, 27, 12, 584);\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, p, anchor);\n      },\n      d: function destroy(detaching) {\n        if (detaching) detach_dev(p);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block,\n      id: create_each_block.name,\n      type: \"each\",\n      source: \"(27:8) {#each foods as food}\",\n      ctx\n    });\n    return block;\n  }\n\n  function create_fragment(ctx) {\n    let div;\n    let h2;\n    let t1;\n    let ul;\n    let each_value =\n    /*foods*/\n    ctx[0];\n    validate_each_argument(each_value);\n    let each_blocks = [];\n\n    for (let i = 0; i < each_value.length; i += 1) {\n      each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));\n    }\n\n    const block = {\n      c: function create() {\n        div = element(\"div\");\n        h2 = element(\"h2\");\n        h2.textContent = \"Foods Collection:\";\n        t1 = space();\n        ul = element(\"ul\");\n\n        for (let i = 0; i < each_blocks.length; i += 1) {\n          each_blocks[i].c();\n        }\n\n        add_location(h2, file, 22, 4, 492);\n        add_location(ul, file, 25, 4, 537);\n        add_location(div, file, 21, 0, 482);\n      },\n      l: function claim(nodes) {\n        throw new Error(\"options.hydrate only works if the component was compiled with the `hydratable: true` option\");\n      },\n      m: function mount(target, anchor) {\n        insert_dev(target, div, anchor);\n        append_dev(div, h2);\n        append_dev(div, t1);\n        append_dev(div, ul);\n\n        for (let i = 0; i < each_blocks.length; i += 1) {\n          each_blocks[i].m(ul, null);\n        }\n      },\n      p: function update(ctx, _ref) {\n        let [dirty] = _ref;\n\n        if (dirty &\n        /*foods*/\n        1) {\n          const old_length = each_value.length;\n          each_value =\n          /*foods*/\n          ctx[0];\n          validate_each_argument(each_value);\n          let i;\n\n          for (i = old_length; i < each_value.length; i += 1) {\n            const child_ctx = get_each_context(ctx, each_value, i);\n\n            if (!each_blocks[i]) {\n              each_blocks[i] = create_each_block(child_ctx);\n              each_blocks[i].c();\n              each_blocks[i].m(ul, null);\n            }\n          }\n\n          for (i = each_value.length; i < old_length; i += 1) {\n            each_blocks[i].d(1);\n          }\n\n          each_blocks.length = each_value.length;\n        }\n      },\n      i: noop,\n      o: noop,\n      d: function destroy(detaching) {\n        if (detaching) detach_dev(div);\n        destroy_each(each_blocks, detaching);\n      }\n    };\n    dispatch_dev(\"SvelteRegisterBlock\", {\n      block,\n      id: create_fragment.name,\n      type: \"component\",\n      source: \"\",\n      ctx\n    });\n    return block;\n  }\n\n  function instance($$self, $$props, $$invalidate) {\n    let {\n      $$slots: slots = {},\n      $$scope\n    } = $$props;\n    validate_slots('Foods', slots, []);\n\n    const _m_tracker0 = _m_createReactiveWrapper();\n\n    const subscriber = Meteor.subscribe('foods');\n    let foods = [];\n    const writable_props = [];\n    Object.keys($$props).forEach(key => {\n      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(\"<Foods> was created with unknown prop '\".concat(key, \"'\"));\n    });\n\n    $$self.$capture_state = () => ({\n      _m_createReactiveWrapper,\n      _m_tracker0,\n      FoodsCollection,\n      subscriber,\n      foods\n    });\n\n    $$self.$inject_state = $$props => {\n      if ('foods' in $$props) $$invalidate(0, foods = $$props.foods);\n    };\n\n    if ($$props && \"$$inject\" in $$props) {\n      $$self.$inject_state($$props.$$inject);\n    }\n\n    $: _m_tracker0(() => {\n      {\n        if (subscriber.ready()) {\n          $$invalidate(0, foods = FoodsCollection.find({}).fetch());\n        }\n      }\n    });\n\n    return [foods];\n  }\n\n  class Foods extends SvelteComponentDev {\n    constructor(options) {\n      super(options);\n      init(this, options, instance, create_fragment, safe_not_equal, {});\n      dispatch_dev(\"SvelteRegisterComponent\", {\n        component: this,\n        tagName: \"Foods\",\n        options,\n        id: create_fragment.name\n      });\n    }\n\n  }\n\n  if (module && module.hot) {\n    Foods = ___SVELTE_HMR_HOT_API.applyHmr({\n      m: module,\n      id: \"imports/ui/Foods.svelte\",\n      hotOptions: {\n        \"preserveLocalState\": false,\n        \"noPreserveStateKey\": [\"@hmr:reset\", \"@!hmr\"],\n        \"preserveAllLocalStateKey\": \"@hmr:keep-all\",\n        \"preserveLocalStateKey\": \"@hmr:keep\",\n        \"noReload\": false,\n        \"optimistic\": true,\n        \"acceptNamedExports\": true,\n        \"acceptAccessors\": true,\n        \"injectCss\": true,\n        \"cssEjectDelay\": 100,\n        \"native\": false,\n        \"importAdapterName\": \"___SVELTE_HMR_HOT_API_PROXY_ADAPTER\",\n        \"noOverlay\": false\n      },\n      Component: Foods,\n      ProxyAdapter: ___SVELTE_HMR_HOT_API_PROXY_ADAPTER,\n      acceptable: true,\n      preserveLocalState: false,\n      cssId: undefined,\n      nonCssHash: undefined,\n      ignoreCss: false\n    });\n  }\n\n  module1.exportDefault(Foods);\n}.call(this, module);","sourceMap":{"version":3,"sources":["Foods.svelte"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;WACsE,iBAAA,KAAA,MAAA,GAAA;;mBAEzD,IAAA,CAAA,CAAA","sourcesContent":["<script>\n    import { createReactiveWrapper as _m_createReactiveWrapper } from \"meteor/zodern:melte/tracker\";\n    const _m_tracker0 = _m_createReactiveWrapper();\n    import { FoodsCollection } from \"/imports/db/foodsCollection\";\n\n    const subscriber = Meteor.subscribe('foods');\n\n    let foods = [];\n\n    $:\n    _m_tracker0(() => {\n        {\n            if(subscriber.ready()){\n                foods = FoodsCollection.find({}).fetch();\n            }\n        }\n    });\n\n\n</script>\n\n<div>\n    <h2>\n        Foods Collection:\n    </h2>\n    <ul>\n        {#each foods as food}\n            <p>food.name</p>\n        {/each}\n    </ul>\n</div>\n"]}}